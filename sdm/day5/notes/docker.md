# docker

- common commands
  - ls: get list of a object
  - rm: remove an object
  - inspect: get details of an object

## images

- template to create container(s)
- image has two unique properties
  - id
  - image name

```bash

# get the list of images
> docker image ls

# download an image from image registry
# registry: collection of images
# - types
#   - public: maintained by docker at hub.docker.com
#   - private: created and accessible only for an organization
# > docker image pull <image name>
> docker image pull hello-world

# get details of an image
# > docker image inspect <image name>
> docker image inspect hello-world

# remove an image
# > docker image rm <image name>
> docker image rm hello-world

```

## containers

- every container by defaults get a unique id when it gets created
- container has two unique properties
  - id
  - container name
- container can be in one of the statuses or states
  - created: container got created
  - Up: container is running
  - Exited: container has stopped (either because of the application running inside the container has successfully stopped or terminated )
- container can run in two modes
  - attached
    - this is the default mode
    - the console (output device) and keyboard (input device) gets directly attached to the container
    - the application's (running inside the container) output will be directly displayed on the console
    - if accidentally the terminal gets killed, the container will also get killed
  - detached
    - the container gets detached from keyboard and console
    - the output will not directly shown on the console
    - even if the terminal is closed, the container will still run in background
- container has only one purpose to run the application configured to run. If the application running inside the container stops, the container also stops immediately
  - when container starts, its starts running the application with PID as 1
  - when the process having PID 1 stops, the container also stops

```bash

# get the list of running containers (containers in the state: Up)
> docker container ls

# get the list of all containers
> docker container ls -a

# create a new container
# > docker container create <image name>
> docker container create hello-world

# start a container
# > docker container start <container id or name>
> docker container start 03b57

# remove an Exited or stopped container
# > docker container rm <container id or name>
> docker container rm 03b57

# remove a running container
# > docker container rm -f <container id or name>
# > docker container rm --force <container id or name>
> docker container rm -f mynginx

# running a container
# - create and start the container immediately
# - every time a new container will get created
# - by default, the newly created container starts running in attached mode
# > docker container run <image name or id>
> docker container run hello-world

# container run command parameters
# --name: used to set name for a container
# -d: used to run the container in detached mode
# -i: used to interact with the container
# -t: teletype: get the terminal from the container
# -v: used to attach a volume
# -p: used to forward a port
# -e: used to set env variable
# > docker container run <params> <image name or id>
# > docker container run --name myhttpd -d httpd

# run a container with port forwarding
> docker container run --name myhttpd -itd -p 8000:80 httpd

# get the log generated by the application running inside the container
# > docker container logs <container id or name>
> docker container logs myhttpd

# get the live logs (as the logs are getting generated)
# - used to monitor a container
# > docker container logs -f <container id or image>

# stop the running container
# > docker container stop <container id or name>
> docker container stop myhttpd

# execute a command inside a container
# > docker container exec <container id or name> <command>
> docker container exec myhttpd date

# get the terminal from container to execute further commands
# > docker container exec -it <container id or name> <bash/sh>
> docker container exec -it myhttpd bash

```

## image customization

- building a new image from existing one to run custom application
- to build a new image we need to use docker instructions
  - FROM:
    - used to select a base image
    - every custom image quires a base image to be selected
    - e.g.
      - for website the base image could be: httpd or nginx
      - for mysql database the base image could be: mysql
      - for express application the base image could be: node
  - COPY:
    - used to copy the file(s) or directories from local machine to image
    - e.g.
      - syntax: COPY <local machine path> <image directory path>
      - COPY index.html /usr/local/apache2/htdocs
      - this command will copy index.html from current directory to htdocs directory inside the image
  - EXPOSE:
    - used to expose the port on which the container will listen for incoming request(s)
    - e.g.
      - for website: EXPOSE 80
      - for express server: EXPOSE 4000
  - WORKDIR:
    - used to set the working directory inside the image
  - RUN:
    - used to execute a command while building the image
    - e.g.
      - RUN npm install express
  - CMD:
    - used to execute a command inside the container
    - only one CMD is allowed in container
    - this must be the last command inside the Dockerfile
    - e.g.
      - CMD node server.js

### exercise 1

- create custom index.html and run inside a container

```html
<html>
  <body>
    <h1>My Website</h1>
    <div>This is my website 1.0</div>
  </body>
</html>
```

- create a new file named Dockerfile and add the following configuration

```Dockerfile

# choose the base image
FROM httpd

# copy the index.html to /usr/local/apache2/htdocs
COPY index.html /usr/local/apache2/htdocs

# expose port 80
EXPOSE 80

```

```bash

# build the image
> docker image build -t mywebsite .

# create container
> docker container run -itd --name mywebsite -p 8006:80 mywebsite

```

### exercise 2

- run express server inside container

```javascript
// server.js

const express = require('express')
const app = express()

app.get('/', (request, response) => {
  response.send('welcome to express application')
})

app.listen(4000, '0.0.0.0', () => {
  console.log('server started on port 40000')
})
```

- create a Dockerfile

```Dockerfile

# choose the base image
FROM node

# choose the working directory
WORKDIR /src

# copy the express app to the working directory
# 1st: all the files in the current directory of local machine
# 2nd: working directory inside the image (/src)
COPY . .

# install express
RUN npm install express

# expose the port
EXPOSE 4000

# run the express application
CMD node server.js

```

```bash

# build the image
> docker image build -t mybackend .

# create container
> docker container run -itd --name mybackend -p 9000:4000 mybackend

```

### exercise 3

- run mysql server inside container

## volumes

- used to persist the data outside the container

```bash

# get list of volumes
> docker volume ls

# create a new volume
# > docker volume create <volume name>
> docker volume create mysql-volume

# attach a volume while running mysql container
# -v: used to set volume
# mysql-volume: name of volume to be used
# /var/lib/mysql: path where the volume will be mounted
# - since the mysql db stores the data in /var/lib/mysql directory, we are using /var/lib/mysql to mount the volumeg
> docker container run -itd --name mysql -p 6606:3306 -e MYSQL_ROOT_PASSWORD=root -v mysql-volume:/var/lib/mysql mysql


```

## docker swarm

- cluster with multiple nodes (machines)
- note:
  - a node can be part of one and only one swarm at a time

```bash

# check if a machine is part of docker swarm
> docker info | grep Swarm

# initialize swarm
# note: the machine on which this command is executed, is by default considered as manager of that swarm
> docker swarm init

# stop the swarm
# - the manager will leave the swarm by stopping it
> docker swarm leave --force

```

### nodes

```bash

# get the list of nodes in a swarm
> docker node ls

# get the details of a selected node
# > docker node inspect <node id>
> docker node inspect g9s

# remove a node from swarm
# note: cluster with one node can not remove itself
# > docker node rm <node id>

```

### service

- used to perform
  - load balancing
  - container management by managing the desired count
- used to define the desired state

```bash

# get the list of services
> docker service ls

# create a new service
# > docker service create --name <service name> <image name>
# parameters
# -p: used for port forwarding
# --replicas: number of replicas (containers) to be created
> docker service create --name myservice httpd

# get service details
# > docker service inspect <service name>
> docker service inspect myservice

# get the details of replicas (containers) created by a service
# > docker service ps <service name>
> docker service ps myservice

# remove a service
# - when the service gets removed, all the containers will also get removed
# > docker service rm <service name>
> docker service rm myservice

# scale (horizontal) the service
# > docker service scale <service name> = <new desired count>

# scaling out the service (increasing the container count)
> docker service scale myservice = 20

# scaling in the service (decreasing the container count)
> docker service scale myservice = 2

```

#### exercises

```bash

# create a service of httpd image with 1 replica and forward port 8000 to port 80 of container
> docker service create --name myservice -p 8000:80 httpd

```
